<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC VLM Demo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .container { max-width: 900px; }
        video, canvas { border-radius: 12px; }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
<div class="container mx-auto p-8 bg-white shadow-xl rounded-2xl flex flex-col md:flex-row gap-8">
    <div class="flex-1 text-center md:text-left">
        <h1 class="text-3xl font-bold text-gray-800 mb-4">WebRTC VLM</h1>
        <p class="text-gray-600 mb-4">Scan this QR code with your phone to start streaming. Ensure both devices are on the same Wi-Fi network.</p>
        <div id="qrcode" class="w-64 h-64 bg-gray-200 rounded-lg mx-auto md:mx-0 flex items-center justify-center text-gray-500">Loading QR...</div>
        <div class="mt-4 p-4 bg-gray-50 rounded-lg">
            <h2 class="text-xl font-semibold text-gray-700 mb-2">Status</h2>
            <p id="status" class="text-sm text-gray-600">Initializing...</p>
        </div>
    </div>

    <div class="flex-1 relative bg-gray-200 rounded-lg overflow-hidden shadow-inner">
        <video id="videoElement" class="w-full h-auto block rounded-lg" autoplay playsinline></video>
        <canvas id="overlayCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script>
    const videoElement = document.getElementById('videoElement');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const statusElement = document.getElementById('status');
    const qrcodeDiv = document.getElementById('qrcode');

    // --- THIS IS THE FIX ---
    // Fallback to 'localhost' if hostname is empty
    const hostname = window.location.hostname || 'localhost';
    const BACKEND_URL = `http://${hostname}:8000`;

    let pc;
    let dataChannel;
    let detectionQueue = [];
    const MAX_QUEUE_SIZE = 1;

    async function startWebRTC() {
        pc = new RTCPeerConnection();

        pc.ontrack = event => {
            videoElement.srcObject = event.streams[0];
        };

        dataChannel = pc.createDataChannel("detections");
        dataChannel.onopen = () => statusElement.textContent = 'Connection established. Waiting for video...';
        dataChannel.onmessage = event => {
            const data = JSON.parse(event.data);
            if (detectionQueue.length >= MAX_QUEUE_SIZE) {
                detectionQueue.shift();
            }
            detectionQueue.push(data);
        };
        dataChannel.onclose = () => statusElement.textContent = 'Connection closed.';

        const offer = await pc.createOffer({ offerToReceiveVideo: true });
        await pc.setLocalDescription(offer);

        const response = await fetch(`${BACKEND_URL}/offer`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ sdp: pc.localDescription.sdp, type: pc.localDescription.type })
        });

        const answer = await response.json();
        await pc.setRemoteDescription(new RTCSessionDescription(answer));
        statusElement.textContent = 'Signaling complete. Waiting for phone to connect...';
    }

    function drawOverlays() {
        const ctx = overlayCanvas.getContext('2d');
        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        if (detectionQueue.length > 0) {
            const { detections } = detectionQueue[detectionQueue.length - 1];
            detections.forEach(det => {
                const { label, xmin, ymin, xmax, ymax, score } = det;
                const width = overlayCanvas.width;
                const height = overlayCanvas.height;
                const x = xmin * width;
                const y = ymin * height;
                const w = (xmax - xmin) * width;
                const h = (ymax - ymin) * height;

                ctx.strokeStyle = '#34D399';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                const text = `${label} (${(score * 100).toFixed(0)}%)`;
                ctx.fillStyle = '#34D399';
                ctx.font = '16px Inter, sans-serif';
                const textWidth = ctx.measureText(text).width;
                ctx.fillRect(x, y - 20, textWidth + 8, 24);
                ctx.fillStyle = '#111827';
                ctx.fillText(text, x + 4, y - 2);
            });
        }
        requestAnimationFrame(drawOverlays);
    }

    videoElement.addEventListener('play', () => {
        overlayCanvas.width = videoElement.videoWidth;
        overlayCanvas.height = videoElement.videoHeight;
        drawOverlays();
    });

    async function initialize() {
        try {
            const response = await fetch(`${BACKEND_URL}/env`);
            if (!response.ok) throw new Error('Failed to fetch IP');
            const env = await response.json();
            const localIp = env.local_ip || hostname;

            const url = `${window.location.protocol}//${localIp}:3000`;
            qrcodeDiv.innerHTML = ''; // Clear "Loading QR..." text
            new QRCode(qrcodeDiv, {
                text: url,
                width: 256,
                height: 256,
                colorDark: "#111827",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
            statusElement.innerHTML = `On your phone, scan the QR code or go to:<br><strong>${url}</strong>`;

            await startWebRTC();

        } catch (error) {
            console.error("Initialization failed:", error);
            statusElement.textContent = 'Error: Could not connect to backend server.';
            qrcodeDiv.textContent = 'Failed to load';
        }
    }

    initialize();
</script>
</body>
</html>
