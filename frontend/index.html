<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC VLM</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        video, canvas { border-radius: 12px; }
    </style>
</head>
<body class="bg-white text-black min-h-screen flex items-center justify-center p-4">
<div class="max-w-4xl w-full p-8 bg-white rounded-2xl flex flex-col md:flex-row items-center gap-8 shadow-2xl shadow-black/20 border border-black/10">
    <!-- Left Panel: QR Code & Status -->
    <div class="flex-1 text-center md:text-left">
        <h1 class="text-4xl font-extrabold mb-2">WebRTC VLM</h1>
        <p class="text-gray-700 text-sm md:text-base mb-6">Scan the QR code with your phone to start streaming live video. Ensure both devices are on the same Wiâ€‘Fi network.</p>

        <div id="qrcode" class="w-64 h-64 bg-white p-2 rounded-lg mx-auto md:mx-0 shadow-md shadow-black/20 border border-black/10 flex items-center justify-center">
            <p class="text-gray-600 font-medium">Loading QR...</p>
        </div>

        <div class="mt-6 p-4 bg-gray-50 rounded-lg shadow-inner border border-black/10">
            <h2 class="text-lg font-semibold mb-1">Connection Status</h2>
            <p id="status" class="text-sm text-gray-700">Initializing...</p>
        </div>
    </div>

    <!-- Right Panel: Video & Overlay -->
    <div class="flex-1 relative bg-black rounded-lg overflow-hidden shadow-xl shadow-black/30 border border-black/10">
        <video id="videoElement" class="w-full h-auto block rounded-lg" autoplay playsinline></video>
        <canvas id="overlayCanvas" class="absolute top-0 left-0 w-full h-full pointer-events-none"></canvas>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script>
    const videoElement = document.getElementById('videoElement');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const statusElement = document.getElementById('status');
    const qrcodeDiv = document.getElementById('qrcode');

    // --- Core WebRTC setup ---
    let pc;
    let dataChannel;
    let detectionQueue = [];
    const MAX_QUEUE_SIZE = 1;
    let BACKEND_URL = '';
    let ROLE = 'viewer'; // 'publisher' on phone, 'viewer' on laptop
    let viewerRetry = 0;
    // Metrics
    let lastFrameId = null;
    const latencies = [];
    const fpsSamples = [];
    let framesInWindow = 0;
    let windowStartTs = performance.now();

    async function startWebRTC() {
        if (!pc) {
            pc = new RTCPeerConnection();
        }

        pc.ontrack = event => {
            videoElement.srcObject = event.streams[0];
        };

        // Viewer creates DC to receive detections from server
        if (ROLE === 'viewer' && !dataChannel) {
            dataChannel = pc.createDataChannel("detections");
            dataChannel.onopen = () => statusElement.textContent = 'Connected. Waiting for video...';
            dataChannel.onmessage = event => {
                try {
                    const data = JSON.parse(event.data);
                    if (detectionQueue.length >= MAX_QUEUE_SIZE) {
                        detectionQueue.shift();
                    }
                    detectionQueue.push(data);
                    // Metrics: latency and FPS
                    const now = performance.now();
                    if (data.capture_ts) {
                        latencies.push(now - data.capture_ts);
                        if (latencies.length > 500) latencies.shift();
                    }
                    if (lastFrameId !== data.frame_id) {
                        lastFrameId = data.frame_id;
                        framesInWindow += 1;
                        const elapsed = now - windowStartTs;
                        if (elapsed >= 1000) {
                            fpsSamples.push(framesInWindow * 1000 / elapsed);
                            if (fpsSamples.length > 300) fpsSamples.shift();
                            framesInWindow = 0;
                            windowStartTs = now;
                        }
                    }
                } catch (e) {}
            };
            dataChannel.onclose = () => statusElement.textContent = 'Connection closed.';
        }

        const offer = await pc.createOffer({ offerToReceiveVideo: true });
        await pc.setLocalDescription(offer);

        const response = await fetch(`${BACKEND_URL}/offer`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ sdp: pc.localDescription.sdp, type: pc.localDescription.type, role: ROLE })
        });

        const answer = await response.json();
        await pc.setRemoteDescription(new RTCSessionDescription(answer));
        statusElement.textContent = 'Signaling complete. Waiting for phone to connect...';

        // In viewer role, retry negotiation a few times if no media arrives
        if (ROLE === 'viewer') {
            setTimeout(async () => {
                if (!videoElement.srcObject && viewerRetry < 5) {
                    try { pc.close(); } catch (e) {}
                    pc = null; dataChannel = null; viewerRetry += 1;
                    statusElement.textContent = `Retrying to attach stream (${viewerRetry}/5)...`;
                    await startWebRTC();
                }
            }, 3000);
        }
    }

    function drawOverlays() {
        const ctx = overlayCanvas.getContext('2d');
        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        if (detectionQueue.length > 0) {
            const { detections } = detectionQueue[detectionQueue.length - 1];
            detections.forEach(det => {
                const { label, xmin, ymin, xmax, ymax, score } = det;
                const width = overlayCanvas.width;
                const height = overlayCanvas.height;
                const x = xmin * width;
                const y = ymin * height;
                const w = (xmax - xmin) * width;
                const h = (ymax - ymin) * height;

                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                const text = `${label} (${(score * 100).toFixed(0)}%)`;
                ctx.fillStyle = '#000000';
                ctx.font = '16px Inter, sans-serif';
                const textWidth = ctx.measureText(text).width;
                ctx.fillRect(x, y - 20, textWidth + 8, 24);
                ctx.fillStyle = '#ffffff';
                ctx.fillText(text, x + 4, y - 2);
            });
        }
        requestAnimationFrame(drawOverlays);
    }

    videoElement.addEventListener('play', () => {
        overlayCanvas.width = videoElement.videoWidth;
        overlayCanvas.height = videoElement.videoHeight;
        drawOverlays();
    });

    // --- QR Code & Initialization Logic ---
    async function initialize() {
        try {
            // Fallbacks based on current page host
            const params = new URLSearchParams(window.location.search);
            const forcedBackend = params.get('backend');
            const forcedHost = params.get('host');
            const host = forcedHost || window.location.hostname || 'localhost';
            const protocol = window.location.protocol;
            const origin = window.location.origin; // includes port if any
            const isTunnel = /\.loca\.lt$/i.test(host) || (protocol === 'https:' && !location.port);
            BACKEND_URL = `${protocol}//${host}:8080`;
            const fallbackPhoneUrl = isTunnel ? origin : `${protocol}//${host}:3000`;

            // Render fallback QR immediately
            if (typeof QRCode !== 'undefined') {
                qrcodeDiv.innerHTML = '';
                new QRCode(qrcodeDiv, {
                    text: fallbackPhoneUrl,
                    width: 256,
                    height: 256,
                    colorDark: "#111827",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.H
                });
                statusElement.innerHTML = `Scan the QR code or go to:<br><strong>${fallbackPhoneUrl}</strong>`;
            } else {
                statusElement.textContent = 'QR library not loaded';
            }

            // Helper to decide if an IP is a private LAN IPv4
            const isPrivateLanIp = (ip) => {
                if (!ip || ip.includes(':')) return false; // ignore IPv6
                if (ip.startsWith('127.') || ip === '0.0.0.0') return false;
                if (ip.startsWith('192.168.')) return true;
                if (ip.startsWith('10.')) return true;
                if (ip.startsWith('172.')) {
                    const octet = parseInt(ip.split('.')[1] || '0', 10);
                    return octet >= 16 && octet <= 31;
                }
                return false; // exclude reserved like 192.0.0.x
            };

            // If a backend override is provided, use it and skip env fetch
            if (forcedBackend) {
                BACKEND_URL = forcedBackend;
                statusElement.innerHTML = `Using forced backend: <strong>${BACKEND_URL}</strong>`;
            }

            // Try to refine with backend-provided IP
            try {
                const envUrl = forcedBackend ? `${forcedBackend.replace(/\/$/, '')}/env` : `${protocol}//${host}:8080/env`;
                const response = await fetch(envUrl);
                if (response.ok) {
                    const env = await response.json();
                    // Allow manual override for tunneling/debug
                    if (window.FORCE_BACKEND_URL) BACKEND_URL = window.FORCE_BACKEND_URL;
                    if (forcedBackend) BACKEND_URL = forcedBackend;
                    const localIp = env.local_ip;
                    const chosenHost = (isPrivateLanIp(localIp)) ? localIp : host;
                    BACKEND_URL = `${protocol}//${chosenHost}:8080`;
                    const phoneUrl = isTunnel ? origin : `${protocol}//${chosenHost}:3000`;
                    if (chosenHost !== host && typeof QRCode !== 'undefined') {
                        qrcodeDiv.innerHTML = '';
                        new QRCode(qrcodeDiv, {
                            text: phoneUrl,
                            width: 256,
                            height: 256,
                            colorDark: "#111827",
                            colorLight: "#ffffff",
                            correctLevel: QRCode.CorrectLevel.H
                        });
                        statusElement.innerHTML = `Scan the QR code or go to:<br><strong>${phoneUrl}</strong><br><span class="text-xs text-gray-600">Backend: ${BACKEND_URL}</span>`;
                    }
                    // Decide role: phone acts as publisher (has camera), laptop as viewer.
                    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
                    if (isMobile) {
                        ROLE = 'publisher';
                        statusElement.textContent = 'Requesting camera on phone...';
                        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 640 }, height: { ideal: 480 }, frameRate: { ideal: 15 } }, audio: false });
                        pc = new RTCPeerConnection();
                        stream.getTracks().forEach(track => pc.addTrack(track, stream));
                        videoElement.srcObject = stream;
                        await startWebRTC();
                        statusElement.textContent = 'Publishing video...';
                    } else {
                        ROLE = 'viewer';
                        const useWasm = (env.mode === 'wasm');
                        if (useWasm) {
                            const worker = new Worker('worker.js');
                            let workerReady = false;
                            let inferPending = false;
                            worker.onmessage = (e) => {
                                const { type, payload } = e.data;
                                if (type === 'init_complete') {
                                    workerReady = true;
                                } else if (type === 'result') {
                                    if (detectionQueue.length >= MAX_QUEUE_SIZE) detectionQueue.shift();
                                    detectionQueue.push(payload);
                                    inferPending = false;
                                }
                            };
                            worker.postMessage({ type: 'init', payload: { modelUrl: '' } });
                            const off = document.createElement('canvas');
                            const captureAndSend = () => {
                                if (!workerReady || inferPending || !videoElement.videoWidth) return;
                                off.width = 320; off.height = 240;
                                const ctx = off.getContext('2d');
                                ctx.drawImage(videoElement, 0, 0, off.width, off.height);
                                const imgData = ctx.getImageData(0, 0, off.width, off.height);
                                const capture_ts = performance.now();
                                inferPending = true;
                                worker.postMessage({ type: 'infer', payload: { frameData: imgData.data.buffer, capture_ts } }, [imgData.data.buffer]);
                            };
                            setInterval(captureAndSend, 100);
                        }
                        await startWebRTC();
                    }
                } else {
                    statusElement.textContent = 'Using local host fallback (backend env unavailable)';
                }
            } catch (_) {
                statusElement.textContent = 'Using local host fallback (backend not reachable)';
                if (forcedBackend) {
                    statusElement.textContent += ` Attempted: ${forcedBackend}`;
                }
            }

            // Periodically compute and POST metrics to backend
            setInterval(async () => {
                if (!BACKEND_URL) return;
                const sorted = [...latencies].sort((a,b)=>a-b);
                if (sorted.length === 0) return;
                const median = sorted[Math.floor(sorted.length/2)] || 0;
                const p95 = sorted[Math.floor(sorted.length*0.95)] || median;
                const avgFps = fpsSamples.length ? (fpsSamples.reduce((a,b)=>a+b,0)/fpsSamples.length) : 0;
                const payload = {
                    latency_ms: { median: Math.round(median), p95: Math.round(p95) },
                    fps: { average: Number(avgFps.toFixed(2)) },
                    samples: { latency_count: sorted.length, fps_count: fpsSamples.length }
                };
                try {
                    await fetch(`${BACKEND_URL}/metrics`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                } catch (_) {}
            }, 3000);
        } catch (error) {
            console.error('Initialization failed:', error);
            statusElement.textContent = 'Initialization error';
        }
    }

    initialize();
</script>
</body>
</html>
